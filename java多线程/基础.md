## java线程基础

1. 创建线程有两个方法。
2. 在java中一个线程就是一个对象（thread实例），创建一个线程与创建其他的对象不同的是，java虚拟机会为每个线程分配调用栈（call stack）所需的空间。
3. java 中的每个线程可能还有一个内核线程。
4. 线程创建的两种方式的区别
5. java线程属性
   1. id的唯一性只能建立在同一个虚拟机一次启动的情况下.
   2. java线程优先级属性本质上只是一个给线程调度信息的提示信息,以便于线程调度器决定优先调度那些程序运行.
6. 按照线程是否会阻止java虚拟机正常停止,可以将java中的线程分为,守护线程和用户线程.守护线程用于执行一些重要性不是很高的任务,例如用于监视其它线程的情况.
7. Thread 类的常用方法.
   1. start方法只能调用一次
8. thread的一些废弃的方法.

## 线程间的层次关系.

1. 一个线程的优先级默认与它的父线程相同.
2. 线程的状态.
3. 线程转储( Th read dump)

## 竞态:

 程序在不同的运行时间中的结果不同.

## 竟态模式和产生的条件

两种竟态模式:

1. 读改写
2. 检测而后行动

产生出竟态条件的一般条件:

1. 一个共享变量被两个操作交错读写.

线程安全:

### 线程安全问题:

三个方面:原子性,可见性,有序性.

原子性:

1. 原子操作是针对与访问共享变量来说的,涉及局部变量的访问操作无所谓原子性.
2. 只在多线程的情况下有意义.
3. java 有两种方式实现原子性:
   1. cas (硬件层次)
   2. 锁(软件层次)
4. java中long型和double型以外的任何类型的变量的写操作都是原子操作.long 和double 型变量的写操作.由于java语言的规范不保证其有原子性.如果用一个volatile
5. java锁的实现机制
6. 循环不变表达式外提



可见性:

一个线程对某个共享变量进行了修改后,后续访问该变量的线程可能无法立刻读取到这个变量,或者永远无法读取到这个变量.

有与jit的编译优化可能导致数据不可见

可见性问题还可能与计算机操作系统有关.程序中的变量可能会被分配到寄存器中而不是内存中进行存储.每个处理器都有其寄存器,如果在多个处理器中运行.那么就会出现可见性问题 .即便是数据是存在内存中,也会因为缓存问题,而导致数据不可见性.

缓存同步

java平台中如何保证可见性?

volatile 关键字提示jit编译器被其修饰的变量可能被多个线程共享.另外一个作用就是当读取一个volatile变量时会使相应的处理器执行刷新处理器缓存的动作.

对于可见性:相对新的值,最新值.

可见性的保障仅仅意味着一个线程能够读取到共享变量的相对新值,但不能够保障该线程能够读取到相应变量的新值.

单处理器系统是否存在可见性问题?

可见性问题时多线程衍生出来的问题,与目标运行环境是单cpu还是多cpu无关.

java语言规范保证,父线程在启动子线程之前对共享变量的 更行对于子线程来说是可见的.

指令重排 的举例.

重排序不是必然出现的.

处理器乱序执行:

1. 现代处理器为了提高指令执行效率,往往不是按照程序顺序被处理器执行的.如果那一条指令就绪了就执行那一条(哪一条指令的操作数就绪了)
2. 处理器的猜测执行技术.

存储子系统.(写缓冲器和高速缓冲器)(其重排序的对象是内存操作的结果)

只有数据依赖关系的语句不会被重排.存在控制依赖关系的语句是可以被重排的.

从底层来讲禁止重排序,是调用cpu的底层指令来实现的.

引起上下文切换的方法.

上下文切换的开销

## 线程的活性故障

线程虽然处于runnable状态但是其要执行的任务却一直无法进展的现象.

1. 锁死
2. 死锁
3. 活锁
4. 饥饿

同一时间内,处于运行状态的线程数量越多,就称并发的程度越高.

公平的调度方法和非公平的.以及线程等待队列.



