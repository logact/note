# 线程同步机制

一套用于协调线程间数据访问及活动的机制.

Java平台提供的线程安全机制

volatile 关键字,final,static,object.notify 

锁的类型:互斥锁, 读写锁.

内部锁,显示锁

java实现锁的机制.

java获得锁的这个步骤隐含着刷新处理器的这个动作,释放锁的这个过程,则隐含着冲刷处理器缓存这个操作.

对同一组共享变量读取时要加上同一个锁(即使只是读操作,防止读到脏数据)

可重入锁: 一个线程在持有一个锁的时候能否多次申请该锁.

可重入锁是如何实现的?

java平台中的调度锁方法包括:公平和非公平.内部锁是非公平,显示锁两者都支持.

## 锁的开销

锁的开销主要由申请锁和释放锁.以及锁可能导致的上下文切换的开销.

1. 锁泄露:由于程序错误,一直没有把持有的锁释放.

2. 导致死锁和锁死

## 内部锁:Synchronized关键字.

 java的任意对象都有一个内部锁.

同步方法的整个方法就是一个临界区.

锁句柄

作为锁变量那个的值一般都是不可变的不然就会造成锁的不同,从而引起竟态.

```java
private final Object  lock =new Object();
```

同步静态方法相当于将当前类的class对象作为锁.

内部锁的申请与释放的动作有java虚拟机负责代为执行.

内部锁的使用不会出现锁泄露的情况.javac 将临界区代码编译时对可能抛出异常进行了特殊的处理(代为处理),代码即使抛出异常,也不会影响内部锁的释放.

### 内部锁的调度机制.

java虚拟机会为每个内部锁分配一个入口集,用于记录等待获得相应内部锁的线程.

## 显示锁

显示锁的调度:

1. 总的来说公平锁的开销要比非公平锁的开销要大,所以默认的是非公平锁.

两种锁的比较:

1. 内部锁相对死板,如法发挥面向对象的优势,也无法将临界区跨方法.支持了一些内部锁不支持的特性.但是由于程序的编写可能会容易造成锁泄漏.
2. 显示锁提供了一些接口(方法)可以用来对锁的相关信息进行监控.而内部锁不支持这种特性.

两者在性能方面的主要差异:

1. Java内部锁做了一定程度的优化
2. 在高争用的情况下内部锁的性能直线下降.而显示锁的性能下降要少得多.(显示锁的可伸缩性要比内部锁的好)

## 读写锁:

1. java.util.concurrent.locks.ReadWriteLock 接口是对读写锁的抽象.默认实现是java.util.concurrent.locks.ReentrantReadWriteLock

2. 读写锁使用的条件

   1. 只读操作比写(更新)操作要频繁的多;
   2. 读线程持有锁的时间比较长.

   

3. 锁的降级,升级

   1. 读写锁支持降级不支持升级,如果要将一个读锁升级为一个写锁,就要先释放读锁.

锁的两种使用金典情况:

1. check-and-act;
2. read-and-write;

## 内存屏障:

内存屏障是对一类仅针对内存读,写操作指令的跨处理器架构的比较底层的抽象.

内存屏障是被插入到两条指令间的一道墙。禁止编译器处理器重排序从而保证其有序性。

内存屏障的划分：

1. 按照可见性保障来划分：加载屏障存储屏障。
2. 按照有序性保障划分：获取屏障释放屏障。

jit重排序的规则：许进不许出。

## volatile

1. 被它修饰的变量必须从高速缓存或者内存中读取，获取变量相对新值。因此被它修饰的变量不会被编译器分配到寄存器中进行储存。
2. 被称为轻量级锁，保证可见性和有序性仅能保证对，volatile写的原子性，没有锁的排他性。不会引起上下文切换
3. volatile 的作用： 保证可见性，保障有序性，保障long/double变量读写操作的原子性。
4. 写volatile 变量操作与该操作之前的任何读，写操作不会被重排序。
5. 读volatile变量操作与该操作之后的任何读，写操作不会被重排序。





## 多线程中的单例模式

1. 基于双重检查锁定。
2. 基于静态内部类实现。

jvm 层面对对象内容（例如静态变量的一次加载）的初始化是线程安全的。

ABA 问题





对象的初始化安全：重访final和static。

Java中的类的初始化实际上也采用了延迟加载的技术。

static在多线程状态下有着特殊的含义它能够保证在多线程情况下即使在未使用任何显示的同步机制的情况下，也能够保证总是可以读取到一个类的静态变量的初始值。

对于引用型变量，static 关键字还能够保证一个线程读取到该变量的初始值的时候，这个值锁指向的对象的初始化已经完毕。

final关键字的作用：

1. 当一个对象发布到其它线程的时候，该对象的所有final字段都是初始化完毕的。



安全发布与逸出

Java中的锁都是可重入锁。读写锁是一个锁实例充当两个角色，并不是两个独立的锁。







