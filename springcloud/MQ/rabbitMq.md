# RabbitMQ

1. 消息队列解决的问题

   1. 异步处理
   2. 应用解耦
   3. 流量削峰
   4. 日志处理

2. 基于amqp协议,使用erlang 语言

   高级消息协议.

3. 与spring AMQP完美整合

4. 集群模式丰富,表达式配置,HA模式,镜像队列模式

5. 保证数据不丢失的前提下做到高可靠性,可用性

rabbitMQ高性能的原因:采用了erlang 语言

## 什么是AMQP协议

具有现代特征的二进制协议.是一个提: 供统一消息服务的应用层标准高级消息队列协议,是应用层协议的一个开发标准.为面向消息的中间件设计.AMQP协议模型

### server 



### connnection

### channel

发送消息也可以发送到队列中.

### message

### virtual host

一个项目都是使用一个虚拟主机,一个虚拟主机绑定在一个用户上

### exchange: 交换机

默认有七种

### binding: exchange 与Queue之间的虚拟连接

### routing key



### queue 

生产者只要关注exchange 消费者只要关注queue

## rabbitmq 的消息 发送模式

7种



### 1.直连(最简单的模型)

问题:消息堆积

### 2.work queue

一个生产者对应多个消费者

默认情况下 rabbitMQ 将按顺序将每个消息发送到下一个使用者,平均每个消费者都会收到相同数量的消息,这种分发消息的方式称为循环.

如何改变这种情况?(如果消费者的之间的处理速度是不一样的)

rabbitMQ的消息确认机制:

消费者如果在basicConsume方法中如果设置了自动确认为true那么在消费者取消费的产品的时候就会一次性把所有的产品都分配给消费者,然后自动确认.

如何实现能者多劳

### 3.fanout(删除模型)广播模型

在广播模式下,消息发送流程:

1. 可以有多个消费者
2. 每个消费者都有自己的队列
3. 每个队列都要绑定到Exchange(交换机)
4. 生产者发送的消息,只能送到交换机,交换机来决定要放给哪个队列,生产者无法决定.
5. 交换机把消息发送给绑定的所有队列
6. 队列的消费者都能拿到消息,实现一条消息被多个消费者消费

### 4.direct模式

在fanout 模式中,一条消息,会被所有订阅的队列都消费,但是,在某些场景下,我们希望不同的消息被不同的队列消费.这时就要用到Direct类型的Exchange.

在Direct 模型下队列与交换机的绑定,不能是任意的绑定了,而是要指定一个RoutingKey 消息的发送方在向Exchange 发送消息时,也碧血指定消息的RoutingKey. Exchange 不再把消息交给每个绑定的队列,而是根据Routing Key进行判断,只有Routingkey 与消息的routing key完全一致,才会接收到消息.