# 接口，lambada ，内部类

## Interface

1. java 1.8可以在方法中提供简单的方法但是不能访问实例域。

2. Interface 中的方法都是公共的没有私有的（如果定义为私有的那么就会报错），如果没有定义修饰符那么就会自动的变为public.接口中的方法都自动从属与public。（在声明中可以不用提供关键字public）。

3. 在接口中如果定义了一个静态方法那么一定要有方法体。

4. 接口中禁止定义所有的代码块（包括静态代码块和普通代码块）

5. default方法是在java8中引入的关键字，也可称为Virtual extension methods——虚拟扩展方法。是指，在接口内部包含了一些默认的方法实现（也就是接口中可以包含方法体，这打破了Java之前版本对接口的语法限制），从而使得接口在进行扩展的时候，不会破坏与接口相关的实现类代码。

6. 在对于int 之间的比较时要注意两个数相减溢出的情况（在用compareTo()方法）

7. 相减的技巧不适用double类型的数据因为精度原因会让两个相差非常相近的数相减的结果为0（四舍五入）；

8. compareTo 方法要符合反对称的要求。

9. 在不同的关系之间实现compareTo（）这样的函数。
   1. 如果只有一种通用的方法能够比较所有的对象则应该在父类中定义compareTo()并将其设置为final
   2. 在比较之前就判断两个是否属于同一种类型。
   
10. 接口中定义的变量是都是共有的 （the private isn't allowed）可以在接口中定义静态变量。

11. java单继承的好处？？？？？？？？

12. 将静态方法添加到接口中是一个不太好的处理。有违将接口作为抽象规范。一般的做法是将静态方法放在与之相关的伴随类（工具类）。

13. 接口演化与默认方法的关系：

    1. 应用场景：

       比如在Java8中给collection接口添加新的方法如果没有将这个方法设置为默认方法那么已经所有以前实现了这个接口的类都要受到影响。而使用默认方法则可以避免这个问题。

14. 解决默认方法冲突

    1. 问题：如果在超类或另一个接口中定义了同样的方法会发生声明情况？
    2. 规则：
       1. 超类优先，如果超类和接口继承了同一个具体的方法那么超类优先。
       2. 接口冲突。如果俩个接口you'yi'ge柄部实现了方法那么会自动继承某一个接口默认方法会让程序员来解决这个二义性。
       3. 如果都是两个接口都没有为共享方法提供默认实现那么就和之前的情况是一样的。
       4. 如果方法签名相同但是返回值不同：？？？然后文本继续指出，如果方法签名具有不同的返回类型，比如`double`和`int`，那么将无法在同一个类中实现两个接口，并且会产生编译时错误。也就是说这样的形式是Java所不允许的。
       5. 不能为让一个默认方法重新定义Object类中的方法。因为类优先的规则下面所有的接口实现的object类中的同名方法是无法超过Object类中方法使用的优先级的。

15. Java回调。

    1. 这里有一个监听器的实例。

16. comparator接口

    在Arrays.sort(array1,比较器)这里要注意我们会想当然的认为这个调用比较器的时候应该调用他的静态方法（因为比较哪两个对象与是哪个比较器的实例无关但是由于这是实现的接口所有的类（通过接口性质的来）所以它的比较方法肯定不能是静态方法）接口中要继承的方法肯定是不能用static所定义的，因为接口方法在所有的所属同一类的对象都是相同的，这就要求这个方法的实现应该要在接口或者超类这个层级实现。

17. 对象与克隆

    1. 从object 对象继承的clone()是一个protected方法,只有这个类的方法，和所属这个类的实例可以访问这个对象，Java对象能够访问父类的protected方法（如果父类没有覆盖祖先类的方法那么这个方法就会被视为子类的方法而不是父类的方法这个子类是不能访问这个方法的）但是如果祖先类中如果显示的定义了一个受保护的方法那么这个子类通过这个祖先类是可以访问这个对象的受保护方法。

    2. 利用子类可以提升父类方法访问权限的特性，虽然存在超类优先但是通过这种扩展访问权限的方法就可以破除（父类的方法不能被找到那么就只能在子类中找了）所以可以直接给让它实现cloneable接口。
    3. 对于protected的总结在一个类中如果定义了一个protected那么后续继承的类都可以访问它的这个方法，但是如果在这个继承链中间有类没有覆盖这个方法，那么继承它的那个类将不能访问这个类的protected方法，这就像把这个继承访问的链条打断了（如果这个继承过程中没有一直将这个方法覆盖过去）(只能访问父类的protected方法),但是能够用super的方式调用父类的所有方法（包括父类从祖先类上继承的方法）。父类祖先类可以访问子孙类从父类中继承过去的protected方法,protected包可见是指与第一定义这个类的方法的包相同。

18. 如果类没有实现cloneabel接口那么就会出.CloneNotSupportedException

19. 所有的数组类型都有一个clone方法。

## lambda表达式

1. 目的：
   1. 简化传递代码块的方式。
   2. 使用与要传递某一个方法。
2. 参数形式
3. 函数式接口
   1. 由于接口中可以定义非抽象类所以可以将父类中的抽象方法变为非抽象的方法。
   2. 只能将lambda表达式赋值给一个函数是接口（只有一个抽象方法的接口）
4. 方法引用
   1. 传递已有的方法
   2. 格式 :: 方法名
   3. 有三种形式的方法：
      1. object::instanceMethod(); System.out::prinltn;
      2. Class::staticMethod(); Math::pow;
      3. Class::instanceMethod();String::compareToIgnoreCase;
   4. 方法引用不能独立的存在，总是会转换为函数式接口实例。
   5. 使用this::,super::也是合法的。
5. 构造器引用
   1. person::new
   2. 可以用数组类型来建立构造器的引用。int[]::new 等价于x->new int[x]
   3. 一点点流的操作（）；
6. 变量作用域
   2. lambda表达式有三个部分：
      1. 一个代码块
      2. 参数
      3. 自由变量，非参数而且不在代码块中定义的变量。
   3. 对于lambda表达式的自由变量的问题。
      1. 他能够存储这个变量的值、
      2. 不能在他之前改变这个变量的值
      3. 它能读取这个方法的参数或者final变量。
      4. 在表达式中也不允许改变变量的值。（造成线程不安全）以后再议。。。。。。。。。。
      5. lambda表达式中捕获的变量必须是最终变量。（这个变量在初始化之后就不会在为它赋新的值）
      6. lambda表达式中声明与一个局部变量同名参数或局部变量是不合法的。
      7. 在lambda表达式中引用this和在这个类其它的位置引用this是一样的。
      8. 它的作用域嵌套在它所属的方法内。