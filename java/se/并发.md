# 并发

## 线程

一个任务被称为线程，可以同时运行多个线程的程序被称为多线程程序。

### 多进程与多线程的区别？

1. 本质区别在于每个进程拥有自己的一整套变量，而线程之间的共享数据。
2. 共享变量使线程之间的通信比进程之间更加方便
3. 在有些操作系统中线程更加容易创建，撤销，更加轻量级

如果需要执行一个耗时比较久的任务就要使用多线程。

### 创建线程的多个方式

1. 给Thread 类传递一个实现了Runnable接口的实现类
2. 创建一个Thread类型的子类（直接在子类中覆盖父类的run方法）
3. 推荐第一种，使用第二种如果有多个任务就会要给每个任务创建一个线程。
4. 执行start方法才会创建一个开启一个执行run方法的新线程。

## 中断线程

用stop方法终止线程的方法已经被弃用了。

### interrupt方法

没有可以强制终止线程的方法，然而interrupt方法可以用来请求终止线程。每当调用这个方法时，线程中断状态就将被置位。这是每一个线程都具有的Boolean标志。每个线程都应该不时的检查这个标志，以判断线程是否被中断。

### isInterrupted方法

调用isInterrupted查看线程是否被置位，但是如果线程被阻塞那么就无法检测中断状态。当在一个被阻塞进程（掉用sleep或者wait）上调用interrupt，阻塞调用将会被Interrupt Exception中断。

中断京城不意味着这个进程应该被终止。终端进程不过引起它的注意。被中断的线程可以决定如何响应中断。某些进程会在处理完异常后，继续执行，不理会中断。大部分情况，进程简单的将中断作为一个终止的请求。

如果在中断进程中调用sleep还会抛出InterruptedException,而不会去休眠。

Interrupted方法：这是一个静态方法，检测当前的进程是否被中断，调用它会清除该线程的中断状态。

不要将中断异常抑制很低的层面（就是不要在底层代码上直接捕获这个异常抑制忽视它）理想情况应该要抛出。

如果非要给一个catch 这个异常的化就要用下面这种方式。

```java
//给catch处理中 加入Thread.currentThread.interrupt()
这将让线程状态重新置位，好让其调用者可以对其进行检测。
```

最好直接抛出这个（InterruptedException异常）

这个调用者（或者，最终的run方法）会捕获这个异常。

## 线程状态

线程有如下六种状态

1. New
2. Runnable
3. Blocked
4. Waiting  等待
5. Timed waiting 记时等待
6. Terminated  被终止

### 线程新创建：

1. 当用new 操作符创建一个新线程时（new Thread(r)）这个时候就是new 状态的线程（线程代码还没有运行），在新创建状态时，还有一些基础工作要做（什么基础工作？(new 一个Thread的开销？)）在线程运行之前。

### 可运行线程：

一旦调用start()方法线程就进入了Runnable状态。一个可运行的线程也可能没有运行，这取决与操作系统给线程提供运行的时间。一个线程开始运行，它不必始终保持运行，运行中的线程可能被打断（这些具体的调度细节取决于操作系统的底层细节）。

现在的桌面操作系统和服务器操作系统采用的抢占式调度（手机可能是协作式）。在这种情况下只有在调用yield方法，或者被阻塞或等待时，线程才会失去控制权。

### 被阻塞和等待线程：

线程处于被阻塞或等待状态的时候，它暂时不活动，他不运行任何的代码且小号最少的资源，知道线程重新激活它。细节取决于他是怎么样到达这个非活动状态。

1. 当一个线程视图获得一个内部的对象锁时，就会进入线程阻塞状态（等待其它的线程释放这个锁）
2. 当线程等待另一个线程通知调度器一个条件时就会，让自己进入等待状态。在调用Object.wait（）方法，和Thread.join方法，或者等待java.util.concurrent中的锁时就会出现这种状态。实际上，被阻塞的状态和等待状是有很大的不同的。
3. 有几个方法有一个超时参数时。 调用他们导致线程进入计时等待状态。这一状态将一直保持到超时期满或者接受到适合的通知。带有超时参数方法有
   1. Thread.sleep()
   2. Object.wait()
   3. Thread.join()
   4. Lock.tryLock()
   5. Condition.await()
4. 线程之间的转换关系图

### 线程被终止

线程有如下两个原因之一而被终止：

1. 因为run方法正常退出而自然死亡
2. 因为没有捕获的异常终止了run方法而意外死亡

可以调用线程的stop方法杀死一个线程，该方法抛出ThreadDeath错误对象，由此杀死进程。但是stop方法已经过时了。

api 

```java
void join();//等待终止指定的进程

Thread.State getState();//获得线程的状态（前面所述的六种状态）

suspend();//暂停一个线程，这个方法已经过时了。

resume();//在suspend方法后调用，已经过时。
```





## 线程属性

线程的各种属性包括：

1. 线程优先级
2. 守护线程
3. 线程组
4. 处理位捕获异常的处理器。

### 线程的优先级

java中每个线程都有一个优先级

默认情况下，一个线程继承它的父线程的优先级，可以用setPriority方法提高或者降低任何一个线程的优先级。它可以设置 MIN_PRIORITY（在Thread 类中定义为1，与MAX_PRIORITY之间的任意值。NORM_PRIORITY的值为5.

线程调度器选择线程时会首先选择优先级高的线程。但是线程优先级是高度依赖于操作系统的。当虚拟机依赖于宿主机平台的优先级实现机制时，Java优先级就会被映射到宿主机的优先级上可能会更少也可能会更多。

在Windows下有七个优先级。在Oracle为Linux提供的Java虚拟机中所有线程的优先级就会被忽视，所有线程拥有相同的优先级。



### 守护线程

通过调用

```java
t.setDaemon(true);//将线程转换为守护线程
```

守护线程的唯一作用就是为其它的线程提供服务。例如计时线程。当只剩下守护线程时，虚拟机就退出了。

守护线程应该永远不访问固有资源（文件，数据库）由于在只剩下它就会被中断。

### 为捕获异常的处理器

线程的run方法不能抛出任何的异常。但是，非受查异常会导致线程死亡。

不需要任何的catch子句就能处理这些要传播的异常。在线程死亡之前，异常被传递到一个用于为捕获任何异常的处理器。

```java
void  uncaughtException(Thread t,Threwable e)
```

可以用setUncaughtExceptionHandler方法为任何的现车给安装一个处理器。也可以用Thread的静态方法setDefaultUncaughtExceptionHandler为所有的线程安装一个默认的处理器。替换处理器可以用日志API发送为捕获异常的报告到日志文件中。

如果不安装处理器，默认的处理器就为空，但是如果不为独立的线程安装处理器，此时的处理器就是该线程的ThreadGroup对象。

线程组时一个可以统一管理的线程集合，默认情况下创建的而所有线程都属于相同的线程组，但是不要在自己的程序中使用线程组（因为有更好的特性支持了？？？？？）

ThreadGroup类实现Thread.UncaughtExceptionHandler接口。它的uncaughtException方法做如下操作

1. ...
2. ...
3. ...
4. ...











## 同步

竞争条件

如果在读写操作时添加一些操作可以使得出错的机率增大。

### 锁对象：

synchronized

ReentrantLock(重入锁)：

```java
myLock.lock();
try{
    ...
}finally{
    myLock.unLock();
}
```

如果使用锁就不能使用try-with-catch。解锁的方法不是close()如果把这个方法重名也不行。它的首部希望接收到一个新变量但是，锁的是共享的，他不是新变量。

锁是可重入的，因为线程可以重复获得已经获得过的锁。锁保持一个持有计数器（hold count ) 来跟踪对lock方法的嵌套调用。一个所保护的代码可以调用另个使用相同锁的方法。



公平锁

ReentrantLock(boolean fair);偏爱一个等待时间最长的锁。

条件对象

1. 

## 阻塞队列



## 线程安全的集合

## Callbale&Future

## 执行器

## 同步器

