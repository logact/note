# 泛型程序设计

## 泛型的好处

泛型对于集合类来说至关重要。type parameter 

在Java SE 1.7后可以在构造函数中省略参数类型

```java
ArrayList<String> files =new ArrayList<>();
```

泛型使得程序有更好的可读性和安全性。

使用泛型的挑战：

1. 在类型参数有复杂的类之间的关系（通配符?）??????

## 泛型类与泛型方法

### 泛型类

泛型类可以看成是普通类的工厂。

### 泛型方法

定义一个简单的泛型方法

```java
class ArrayAlg
{
    public static <T> T getMiddle(T...a){
        return a[a.length/2];
    }
   
}
```

泛型方法可以定义在泛型类中，也可以定义在普通类中。

泛型对于编译器的一个重要的点就是编译器可以通过推断类型来减少调用减少添加类型参数。

```java
//调用泛型方法
String middle = ArrayAlg.<String>getMiddle("f","fsd","fs");
//简写形式由编译器推断出来这个方法的类型参数（由方法的参数列表退出）。
String middle = ArrayAlg.<String>getMiddle("f","fsd","fs");

```

但是对于这种情况

```java
double  middle = ArrayAlg.getMiddle(3.14,1729,0);

```

在这种情况下，编译器会自动打包参数为一个Double和两个Integer对象，而后寻找这些类的共同超类。事实上能够找到两个这样的超类型，Number 和Comparable接口，（本身已是一个泛型类）

如何查看编译器最终推出的泛型类型？

```java
故意引入一个错误
```



## 泛型代码与虚拟机

### 类型擦除

虚拟机没有泛型类对象所有对象都是普通类（内部类也是普遍类）。

擦出类型变量，并替换为限定类型（无限定的时候就用Object）如果有多个限定的话，就会替换为限定列表的第一个限定类型。（所以为了效率的提高，应该将标签类（tagging）接口（没有方法的接口放在后面））

### 翻译泛型表达式

当程序调用泛型方法是，如果擦出返回类型，编译器插入强制类型转换。如下的例子：

```java
Pair<Employee> buddies = ...;
Employee buddy = buddies.getFirst();
```

编译器会自动插入Employee的强制类型转换。编译器会将这个方法的调用转换为两条虚拟机指令。

```java
1. 对原始方法的调用
2. 将返回的Object强转为Employee
```

```java
Employee buddy = buddies.body ;
//存取一个泛型域时也要插入泛型转换
```





### 翻译泛型方法

泛型擦出也发生在泛型方法中（擦出后就只有一个方法）

如果继承的一个类是一个泛型类那么由于泛型擦出就会出现，让泛型类参数的的方法变为原始类型，这样子类中的方法就和父类的方法变为了两个完全不相同的方法（参数发生了变化）破坏了多态性质，所以为了修复这种情况使用桥方法将带有擦出后的方法覆盖掉。（但是不加桥方法也行）

```java
桥方法被合成来保持多态


```



### 调用遗留代码

对于在没有实现泛型之间的类中填入泛型的参数可能造成这个类型警告

```java
//产生一个warning
slider.setLabelTable(lablelTable);
//因为这个类的方法可能是这样定义的
class slider{
    ...
    public void setLabelTable(LabelTable var1){
        ...
    }
    //而不是
    public void setlabelTable(LabelTable var2){
        //这样就可以使得编译器能够检查类型安全。
    }
}
```



## 类型变量的限定

```java
<T extends BoundingType> 
/**
bounding Type 可以是类也可以是接口
*/
<T extends BoundingType1 & BoundingTyp2>
/**
使用&就可以指定多个限制但是这些限制只能能有一个类，而且如果若果有一个类在其中它必须凡在这个限制列表的第一位。
*/
```



## 泛型的约束与限制

### 不能用基本类型来实例化类型参数



### 运行时类型查询只适用于原始类型

所有的类型查询只产生原始类型

```java
if(a instanceof Pair<String>)//这只能测试这个类是否属于任意的一个
pair类,a可能是Pair<Double> ,也可能是Pair<Integer>
```

为了提醒这个错误：在试图查询一个对象是否属于某个泛型类的时候，倘若使用instanceof 会得到一个编译错误，强转类型装换会的到一个警告。

### 不能创建参数化类型的数组

由于类型擦出的存在那么就会使得这个数组变为Object类型，那么这个数组记住的类型就是Object，使得数组安全机制无效。

可以声明一个泛型数组

```java
Pair<String> table=(Pair<String>[]) new Pair<?>[10];
```

这样是不安全的，失去了数组能记住它初始时类型的安全机制。

唯一的泛型安全数组ArrayList<>

编译器所作的工作就是进行类型检查（和解决一些将一些高级特性的解析（如在泛型中为泛型类加入强制类型转换，实现泛型的参数安全，生成桥方法维护由于虚拟机层次造成的多态破坏））而虚拟机只负责执行这些已经处理过的代码（不管是否泛型）。

### Varags警告

### 不能实例化类型变量

### 不能构造泛型数组

### 泛型类的静态上下文无效

### 不能抛出或捕获泛型类的实例

### 可以消除堆受查异常的检查

### 注意擦出后的冲突

## 泛型类型的继承规则

## 通配符类型

### 通配符概念 

### 通配符的超类限定

### 无限定的通配符

### 通配符的捕获

## 反射与泛型

### 泛型Class类

### 使用Class<T> 参数进行类型适配

### 虚拟机中的泛型信息

*XMind: ZEN - Trial Version*